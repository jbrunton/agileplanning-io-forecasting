<div class="row">
  <div class="large-12 columns">
    <h1>Epic Cycle Times</h1>

  <style>
      #container, .d3-tip, .d3-tip ul {
          font-family: "Lato","Helvetica Neue",Helvetica,Arial,sans-serif;
          color: #525263;
          font-size: 12px;
          font-weight: 300;
      }

      .d3-tip ul {
          margin-bottom: 0;
      }

      .d3-tip {
          pointer-events: none !important;
          box-shadow: 1px 1px 6px rgba(127, 127, 127, 0.6);
      }

      .d3-tip .header {
          padding: 6px;
      }

      .d3-tip.wip .header {
          background: rgba(240, 240, 255, 0.8);
          border-bottom: solid 1px rgba(200, 200, 250, 0.8);
      }

      .d3-tip.cycle_time .header {
          background: rgba(250, 240, 240, 0.8);
          border-bottom: solid 1px rgba(250, 200, 200, 0.8);
      }

      .d3-tip .content {
          padding: 6px;
      }

      .d3-tip.wip .content {
          background: rgba(250, 250, 255, 0.8);
      }

      .d3-tip.cycle_time .content {
          background: rgba(255, 250, 250, 0.8);
      }

      .axis path,
      .axis line {
          fill: none;
          stroke: grey;
          shape-rendering: crispEdges;
      }

      .chart circle {
          fill: white;
      }

      .chart circle.cycle_time {
          stroke: indianred;
          stroke-width: 1.5px;
      }


      .chart circle.wip {
          stroke: steelblue;
          stroke-width: 1.5px;
      }

      .chart .line {
          fill: none;
          stroke-width: 1.5px;
          stroke-opacity: 0.6;
      }

      .chart .line.wip {
          stroke: steelblue;
      }

      .chart .area.wip {
          fill: steelblue;
          opacity: 0.15;
      }

      .chart .line.cycle_time {
          stroke: indianred;
          stroke-width: 2px;
      }

      .chart .area.cycle_time {
          fill: indianred;
          opacity: 0.15;
      }

      .chart .overlay {
          fill: none;
          stroke: none;
          pointer-events: all;
      }

      #focusCircle {
          fill: white;
          cursor: pointer;
      }

      #container {
          width: 100%;
      }
  </style>

  <script>
      $(function () {
          var bisectDate = d3.bisector(function(d) { return d.completed ? d.completed : d.date; }).left;

          function cycleTimeTip(d, active) {
              var context = { d: d, active: active };
              return HandlebarsTemplates['epic_tooltip'](context);
          }

          function wipTip(d, active) {
              var context = { d: d, active: active };
              return HandlebarsTemplates['wip_tooltip'](context);
          }

          function drawChart(epics, wip) {
              var cycleTimeData = epics[0]
                      .filter(function(item) {
                          return item.epic.completed != null;
                      })
                      .map(function(item) {
                          return {
                              completed: datetime.parseTime(item.epic.completed),
                              cycleTime: item.cycle_time,
                              avg: item.mean,
                              sd: item.stddev,
                              epic: item.epic
                          };
                      });

              var wipData = Object.keys(wip[0]).map(function(date) {
                  return {
                      date: datetime.parseDate(date),
                      wip: wip[0][date].wip,
                      issues: wip[0][date].epics,
                      avg: wip[0][date].mean,
                      sd: wip[0][date].stddev
                  };
              });

              var allDates = cycleTimeData.map(function(d) { return d.completed; })
                      .concat(wipData.map(function(d) { return d.date; }));

              var chart = new CycleTimeChart({
                  container: '#container',
                  aspectRatio: 2.0,
                  margin: {top: 20, right: 30, bottom: 30, left: 40}
              });

              chart.bind();

              var xScale = d3.time.scale()
                      .domain([d3.min(allDates), d3.max(allDates)])
                      .range([0, chart.getClientWidth()], .1);

              var yCycleTimeScale = d3.scale.linear()
                      .domain([0, d3.max(cycleTimeData, function(d) { return d.cycleTime; })])
                      .range([chart.getClientHeight(), 0]);

              var yWipScale = d3.scale.linear()
                      .domain([0, d3.max(wipData, function(d) { return d.wip; })])
                      .range([chart.getClientHeight(), 0]);

              $('.d3-tip').remove();

              var cycleTimeLine = d3.svg.line()
                      .x(function(d) { return xScale(d.completed); })
                      .y(function(d) { return yCycleTimeScale(d.avg); });

              var cycleTimeArea = d3.svg.area()
                      .x(function(d) { return xScale(d.completed); })
                      .y0(function(d) { return yCycleTimeScale(d.avg - d.sd); })
                      .y1(function(d) { return yCycleTimeScale(d.avg + d.sd); });

              chart.svg.append("path")
                      .datum(cycleTimeData)
                      .attr("class", "line")
                      .attr("d", cycleTimeLine)
                      .classed("cycle_time", true);

              chart.svg.append("path")
                      .datum(cycleTimeData)
                      .attr("class", "area")
                      .attr("d", cycleTimeArea)
                      .classed("cycle_time", true);

              var wipLine = d3.svg.line()
                      .interpolate("monotone")
                      .x(function(d) { return xScale(d.date); })
                      .y(function(d) { return yWipScale(d.avg); });

              var wipArea = d3.svg.area()
                      .x(function(d) { return xScale(d.date); })
                      .y0(function(d) { return yWipScale(d.avg - d.sd); })
                      .y1(function(d) { return yWipScale(d.avg + d.sd); });

              chart.svg.append("path")
                      .datum(wipData)
                      .attr("class", "line")
                      .attr("d", wipLine)
                      .classed("wip", true);

              chart.svg.append("path")
                      .datum(wipData)
                      .attr("class", "area")
                      .attr("d", wipArea)
                      .classed("wip", true);

              var focusActive = false;

              var tip = d3.tip().attr('class', 'd3-tip')
                      .direction(function(d) {
                          var y = d.cycleTime ? yCycleTimeScale(d.cycleTime) : yWipScale(d.wip);
                          return y > chart.getClientHeight() / 2 ? 'n' : 's';
                      })
                      .offset(function(d) {
                          var y = d.cycleTime ? yCycleTimeScale(d.cycleTime) : yWipScale(d.wip);
                          return y > chart.getClientHeight() / 2 ? [-10, 0] : [10, 0];
                      })
                      .html(function(d) {
                          var html = "";
                          if (d.cycleTime) {
                              html += cycleTimeTip(d, focusActive);
                          } else {
                              html += wipTip(d, focusActive);
                          }
                          return html;
                      });
              chart.svg.call(tip);

              var xAxis = d3.svg.axis()
                      .scale(xScale)
                      .ticks(5)
                      .orient("bottom");

              chart.svg.append("g")
                      .attr("class", "x axis")
                      .attr("transform", "translate(0," + chart.getClientHeight() + ")")
                      .call(xAxis);

              var yCycleTimeAxis = d3.svg.axis()
                      .scale(yCycleTimeScale)
                      .orient("left");

              chart.svg.append("g")
                      .attr("class", "y axis")
                      .call(yCycleTimeAxis);

              var yWipAxis = d3.svg.axis()
                      .scale(yWipScale)
                      .tickFormat(d3.format("d"))
                      .orient("right");

              chart.svg.append("g")
                      .attr("class", "y axis")
                      .attr("transform", "translate(" + chart.getClientWidth() + ",0)")
                      .call(yWipAxis);

              var cycleTimeCircle = chart.svg.selectAll("circle.cycle_time")
                      .data(cycleTimeData)
                      .enter().append("circle")
                      .attr("cx", function(d) { return xScale(d.completed); })
                      .attr("cy", function(d) { return yCycleTimeScale(d.cycleTime); })
                      .attr("r", 3)
                      .classed("cycle_time", true);

              var wipCircle = chart.svg.selectAll("circle.wip")
                      .data(wipData)
                      .enter().append("circle")
                      .attr("cx", function(d) { return xScale(d.date); })
                      .attr("cy", function(d) { return yWipScale(d.wip); })
                      .attr("r", 1.5)
                      .classed("wip", true);

              var overlay = chart.svg.append('rect')
                      .attr('class', 'overlay')
                      .attr('width', chart.getClientWidth())
                      .attr('height', chart.getClientHeight());

              var focus = chart.svg.append('g').style('display', 'none');
              focus.append('circle')
                      .attr('id', 'focusCircle')
                      .attr('r', 5);

              overlay.on('click', function() { focusActive = false; tip.hide(); focus.style('display', 'none'); })
                      .on('mousemove', function() {
                          function getMouseXY(self) {
                              var mouse = d3.mouse(self);
                              return { x: mouse[0], y: mouse[1] };
                          }

                          function getCycleTimeXY(index) {
                              if (index < 0 || index >= cycleTimeData.length) {
                                  return { x: -999999, y: -999999, data: d };
                              }
                              var d = cycleTimeData[index];
                              return { x: xScale(d.completed), y: yCycleTimeScale(d.cycleTime), data: d };
                          }

                          function getWipXY(index) {
                              if (index < 0 || index >= wipData.length) {
                                  return { x: -999999, y: -999999, data: d };
                              }
                              var d = wipData[index];
                              return { x: xScale(d.date), y: yWipScale(d.wip), data: d };
                          }

                          function distanceSq(p0, p1) {
                              return Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2);
                          }

                          function getClosestCycleTimeXY(p) {
                              var mouseDate = xScale.invert(mouse.x);
                              var i = bisectDate(cycleTimeData, mouseDate); // returns the index to the current data item
                              var p0 = getCycleTimeXY(i - 1);
                              var p1 = getCycleTimeXY(i);

                              p0.dist = distanceSq(p0, mouse);
                              p1.dist = distanceSq(p1, mouse);

                              // work out which date value is closest to the mouse
                              return p0.dist > p1.dist ? p1 : p0;
                          }

                          function getClosestWipXY(p) {
                              var mouseDate = xScale.invert(mouse.x);
                              var i = bisectDate(wipData, mouseDate); // returns the index to the current data item
                              var p0 = getWipXY(i - 1);
                              var p1 = getWipXY(i);

                              p0.dist = distanceSq(p0, mouse);
                              p1.dist = distanceSq(p1, mouse);

                              // work out which date value is closest to the mouse
                              return p0.dist > p1.dist ? p1 : p0;
                          }

                          var mouse = getMouseXY(this);
                          var pCycleTime = getClosestCycleTimeXY(mouse);
                          var pWip = getClosestWipXY(mouse);

                          if (focusActive) {
                              return;
                          }

                          if (pCycleTime.dist < pWip.dist && pCycleTime.dist < 2500) {
                              focus.select('#focusCircle')
                                      .attr('cx', pCycleTime.x)
                                      .attr('cy', pCycleTime.y)
                                      .attr('class', 'cycle_time')
                                      .on('click', function() {
                                          focusActive = true;
                                          tip.show(pCycleTime.data, target);
                                      });
                              var target = d3.selectAll("circle.cycle_time").filter(function(d) { return d == pCycleTime.data; })[0][0];
                              tip.show(pCycleTime.data, target);
                              tip.attr('class', 'd3-tip cycle_time');
                              focus.style('display', null);
                          } else {
                              focus.select('#focusCircle')
                                      .attr('cx', pWip.x)
                                      .attr('cy', pWip.y)
                                      .attr('class', 'wip')
                                      .on('click', function() {
                                          focusActive = true;
                                          tip.show(pWip.data, target);
                                      });

                              var target = d3.selectAll("circle.wip").filter(function(d) { return d == pWip.data; })[0][0];
                              tip.show(pWip.data, target);
                              tip.attr('class', 'd3-tip wip');
                              focus.style('display', null);
                          }
                      });
          }

          function drawReport() {
              var filter = $('#filter').val();
              $.when(
                      $.get('<%= project_path(@project) %>/data/cycle_times.json?filter=' + filter),
                      $.get('<%= project_path(@project) %>/data/wip.json?filter=' + filter)
              ).done(drawChart);
          }

          drawReport();

          $('#filter').on('change', drawReport);
          $(window).resize(drawReport);
      });

  </script>



    <svg id="container" class="chart"></svg>

    <form>
      <div class="row">
        <div class="large-4 columns">
          <label>Date Filter</label>
          <input id="filter" type="text" value="<%= "#{(Date.today - 1.year).strftime('%d %b %Y')} - #{Date.today.strftime('%d %b %Y')}"  %>" />
        </div>
      </div>
    </form>
  </div>
</div>